
- DAO Standards: every DAO:
    - must be related to 1 Entity > Entity can be composed by simpler Entities
        - RDBMS: the Select From [Join] -> Entity(ies) + Descriptive Related other Entities
    - exposes DAOps: DAOps types are: select

    - DAOps standard: it depends on SourceType and [Entity] -> Result = [Entity].[DAOpsNam]([DAOpsParams])
        - DaoSourceType: RDBMS, FS, Component, ExtService
    ------------	--------	------------					-----------		-----------------
    DAOps			RDBMS 								
                    Op			OpType {2}							Result			FullNam
    ------------	--------	------------					-----------		-----------------
    view			Select		Std		Single					0..1 row		selectSingle {1}{4}
                                        All						0..n row(s)		selectAll
                                Spec	Single[FilterParamNams]	0..1 row		selectSingle[FilterParamNams] {1}
                                        All[FilterParamNams]	0..n row(s)		selectAll[FilterParamNams]
    Save			Insert		Std		One	{5}
                                        Multi {3}		
                    Update      Std		One	{5}
                                        Multi {3}

    Delete			Delete		[Single]
                    Clean		[Filter]
                    Truncate	[All]

    [Spec]			[OpNam]		[OpNam][FilterParamNams]
    ------------	--------	------------					-----------		-----------------
    {1}: Single could be omitted, but it stays for sintax disambiguation with select commands;
    {2}: think about generalization of Single/All+Filters ops -> only 1 Op Select[FilterParamNams] with 0..n row(s) result;
    {3}: MULTI could a more precise and general alternative to All.
    {4}: Single should be more precise as OneOrNone; All as MultiOrNone.
         It means that what is determining the = or like clause is the maximum number of rows returned.
    {5}: ONE could an alternative to Single.
----------------------------------------------------------
SELECT examples: 
----------------------------------------------------------
- Entity=Profile: simple entity
----------------------------------------------------------
selectAll()
 
            SELECT
                p.IdProfile,
                p.Nam,
                p.Descr
            FROM
                Profile p
            ORDER BY
                p.IdProfile
----------------------------------------------------------
selectSingle()
            SELECT
                p.IdProfile,
                p.Nam,
                p.Descr
            FROM
                Profile p
            WHERE
                IdProfile = " . $this->IdProfile."
----------------------------------------------------------
Generalization hypothesis:
selectIdProfile()
            SELECT
                p.IdProfile,
                p.Nam,
                p.Descr
            FROM
                Profile p
            WHERE
                IdProfile like '" . $this->IdProfile."%'
            ORDER BY
                p.IdProfile
----------------------------------------------------------
OBSERVATONS:
- to generalize js->Refresh and Dao.ctrl->DbRead methods must not execute Dao if emptyOrNull(IdProfile)
----------------------------------------------------------
-this must be placed in the ProfileFeatureAuth Dao

selectAllFeatureAuth() 
                SELECT
                    p.IdProfile,
                    p.Nam,
                    p.Descr,
                    fc.IdFeatureCat,
                    fc.Nam as FeatureCatNam,
                    f.IdFeature,
                    f.Nam as FeatureNam,
                    f.Descr as FeatureDescr,
                    f.CodeParams as FeatureCodeParams,
                    a.IdAuthLevel,
                    a.Nam as AuthLevelNam,
                    a.AuthLevel as AuthLevel
                FROM
                    Profile p
                    LEFT OUTER JOIN profile_feature_auth pfa on pfa.IdProfile=p.IdProfile
                    LEFT OUTER JOIN feature f on pfa.IdFeature=f.IdFeature    
                    LEFT OUTER JOIN authLevel a on pfa.IdAuthLevel=a.IdAuthLevel    
                    LEFT OUTER JOIN featureCat fc on f.IdFeatureCat=fc.IdFeatureCat    
                WHERE
                    p.IdProfile = " . $this->IdProfile."
                ORDER BY
                    fc.Nam, f.Nam
----------------------------------------------------------
-this must be placed in the ProfileFeatureAuth Dao

selectAllUsrProfileFeatureAuth()
                SELECT
                    u.IdUsr,
                    u.usrNam,
                    count(p.IdProfile),
                    fc.IdFeatureCat,
                    fc.Nam as FeatureCatNam,
                    f.IdFeature,
                    f.Nam as FeatureNam,
                    f.Descr as FeatureDescr,
                    f.CodeParams as FeatureCodeParams,
                    a.IdAuthLevel,
                    a.Nam as AuthLevelNam,
                    max(a.AuthLevel) as AuthLevel
                FROM
                    usr u
                    LEFT OUTER JOIN profile_usr pu on pu.IdUsr=u.IdUsr
                    LEFT OUTER JOIN Profile p on pu.IdProfile=p.IdProfile
                    LEFT OUTER JOIN profile_feature_auth pfa on pfa.IdProfile=p.IdProfile
                    LEFT OUTER JOIN feature f on pfa.IdFeature=f.IdFeature    
                    LEFT OUTER JOIN authLevel a on pfa.IdAuthLevel=a.IdAuthLevel    
                    LEFT OUTER JOIN featureCat fc on f.IdFeatureCat=fc.IdFeatureCat    
                GROUP BY
                    u.IdUsr,
                    fc.IdFeatureCat,
                    f.IdFeature
                HAVING
                    u.IdUsr = " . $this->IdUsr."
                ORDER BY
                    fc.IdFeatureCat,
                    f.IdFeature
----------------------------------------------------------
- this must be placed in the ProfileUsr Dao

selectAllUsrProfile() >> Nam must be: Profile->selectAllIdUsr()

                SELECT
                    u.IdUsr,
                    u.usrNam,
                    p.IdProfile,
                    p.Nam,
                    p.Descr
                FROM
                    usr u
                    LEFT OUTER JOIN profile_usr pu on pu.IdUsr=u.IdUsr
                    LEFT OUTER JOIN Profile p on pu.IdProfile=p.IdProfile
                WHERE
                    u.IdUsr = " . $this->IdUsr."
                ORDER BY
                    p.Nam

- ProfileFeatureAuth: complex Entity


-------------------------------------------------
OBSERVATIONS:
- it is quiet impossible to define a generalized standard for DAO Requests,
  cause they are so variuos.
- As far as I know, It can be done only for basic Select Single-All, Insert, Update, Delete.
- Other requests cannot be limited by a rigid standard:
	- Filters: they affect the OpNam;
	- composed entities: they affect the EntityNam;

- The only way I can see is to define a standard that consider a Composed Entity as a 
  new and different entity from the composing ones.
  ex. Profile, Feature, AuthLevel, Usr are different from any combynation of them: 
	- ProfileFeature, ProfileFeatureAuthLevel, ProfileUsr
? It seems that the order could be ignored: ex. ProfileUsr and UsrProfile can coexist in the same Dao.
    - lets demonstrate it for ProfileUsr <> UsrProfile
-------------------------------------------------
selectAll()
            SELECT
                pu.IdProfileUsr,
                pu.IdProfile,
                p.Nam as ProfileNam,
                pu.IdUsr,
                u.UsrNam
            FROM
                profile_usr pu
                LEFT OUTER JOIN profile p on pu.IdProfile=p.IdProfile
                LEFT OUTER JOIN usr u on pu.IdUsr=u.IdUsr    
            ORDER BY
                p.Nam,u.Nam
-------------------------------------------------
selectSingle()
            SELECT
                pu.IdProfileUsr,
                pu.IdProfile,
                p.Nam as ProfileNam,
                pu.IdUsr,
                u.UsrNam
            FROM
                profile_usr pu
                LEFT OUTER JOIN profile p on pu.IdProfile=p.IdProfile
                LEFT OUTER JOIN usr u on pu.IdUsr=u.IdUsr   
            WHERE
                pu.IdProfileUsr = " . $this->IdProfileUsr." 
-------------------------------------------------
OBSERVATIONS:
- general std select model:
    SELECT
        [StdViewFields] 
    FROM
        [Entity]
    WHERE
        [Filter] 
    ORDER BY
        [OrderingFields]

- [StdViewFields] are defined by: 
    - All Foundamental entity fields (ex. pu.IdProfileUsr, pu.IdProfile, pu.IdUsr)
     +  
    - Descriptive Entities fields related to Foreingn keys Ids (ex. p.Nam as ProfileNam, u.UsrNam)
- [Entity] is always the same (look at the From Clause)
    ex: ... 
    profile_usr pu
    LEFT OUTER JOIN profile p on pu.IdProfile=p.IdProfile
    LEFT OUTER JOIN usr u on pu.IdUsr=u.IdUsr   
    ...
    generaliazed: ... 
    [fundamental Entity] fe
    LEFT OUTER JOIN [descriptive entity 1] de1 on fe.[Id[fundamental Entity]]=de1.[Id[descriptive entity 1]]
    LEFT OUTER JOIN [descriptive entity 2] de2 on fe.[Id[fundamental Entity]]=de2.[Id[descriptive entity 2]]   
    ...
    - where - profile_usr is the fundamental entity
            - profile, usr entities become descriptive.
- [Filter] WHERE or HAVING conditions, are the most complex part to generalize
- [Ordering fields] a std could be:
    - Descriptive 'Nam' Fields, if they exist
    or
    - Foundamental Entity Id, if not

- The IdProfileUsr = IdUsrProfile and is unique;

- Generalizations should be:
-------------------------------------------------
    Std generalization

...    WHERE
        pu.IdProfileUsr like '" . $this->IdProfileUsr."%' 
...
-------------------------------------------------
    Relational generalizations

selectAllIdProfileIdUsr()   
...    WHERE
        pu.IdProfile like '" . $this->IdProfile."%' and
        pu.IdUsr like '" . $this->IdUsr."%'
...
-------------------------------------------------
selectAllIdProfile()    
...    WHERE
        pu.IdProfile = " . $this->IdProfile." 
...
-------------------------------------------------
selectAllIdUsr()
...    WHERE
        pu.IdUsr = " . $this->IdUsr." 
...
-------------------------------------------------
selectAllIdProfileIdUsrEx()   
...    WHERE
        pu.IdProfile = " . $this->IdProfile." XOR
        pu.IdUsr = " . $this->IdUsr."
...
-----------------------------------------------------

-----------------------------------------------------
CONCLUSIONS for SELECT
- a Dao component must be considered as a wrapper encapsulating a dataSourse Entity (ex. rdbms table or join of tables);
- a std adapter Dao can be defined setting up, with STD COMPOSITION RULES (see the hypothesis above):
    - Entity, Fields, Ordering fields, Filters 
- STD COMPOSITION RULES can be introduced in order to have multiple options for Code composition.
- a Code Builder should include a Composition Rule Editor.

-----------------------------------------------------
OTHER OBSERVATIONS
? A greater problem is the reverse engineering of the Entity, starting from the Sql From clause
    ? could be done with the Analyst interaction selecting fundamental and description assets

----------------------------------------------------------
----------------------------------------------------------
INSERT and UPDATE examples: 
----------------------------------------------------------
    Save			Insert		Std		One	
                                        Multi 		
                    Update      Std		One	
                                        Multi 

OBSERVATIONS:
- Insted of passing single row syntax of the INSERT,
  One, Multi can be generalized considering passing a commun Matrix to the Insert method:
    - One: passing a one row Matrix
    - Multi: passing a multiple rows Matrix

Single row syntax
    INSERT INTO  Profile
            (Nam,Descr)
    VALUES
        (" . VN($this->Nam)     . ",
         " . VN($this->Descr)   . "
        )"
    ;

Multi rows syntax
    INSERT INTO Profile
            (implode(', ', $array_keys(Matrix[0])))
    VALUES
        foreach ($Matrix as $Row){
            (implode(', ', $array_values($Row))),
        }
    ;
    
Matrix: structure with key-value pairs, passed by JSON
    ex. AlgCat
    "Matrix":[
    {"IdAlgCat":"1","IdAlgCatPar":null,"Nam":"Clean","Descr":"Clean Algs"},
    {"IdAlgCat":"2","IdAlgCatPar":1,"Nam":"aaa","Descr":"aaa Algs"},
    {"IdAlgCat":"3","IdAlgCatPar":null,"Nam":"bbb","Descr":"bbb Algs"},
    {"IdAlgCat":"4","IdAlgCatPar":4,"Nam":"ccc","Descr":"ccc Algs"},
    {"IdAlgCat":"5","IdAlgCatPar":null,"Nam":"ddd","Descr":"ddd Algs"},
    {"IdAlgCat":"6","IdAlgCatPar":6,"Nam":"eee","Descr":"eee Algs"},
    {"IdAlgCat":"7","IdAlgCatPar":null,"Nam":"fff","Descr":"fff Algs"}
    ]


----------------------------------------------------------
UPDATE examples: 
----------------------------------------------------------


Single row syntax
    UPDATE
        Profile
    SET
        Nam="   .VN($this->Nam) . ",
        Descr=" .VN($this->Descr) . "
    WHERE
        IdProfile='" . $this->IdProfile . "'

Multi rows syntax
    INSERT INTO Profile
            (implode(', ', $array_keys(Matrix[0])))
    VALUES
        foreach ($Matrix as $Row){
            (implode(', ', $array_values($Row))),
        }
    ON DUPLICATE KEY UPDATE
        implode(', ', $array_keys(Matrix[0])
    ;
---------------------------------------------------------------
!!! IMPORTANT: with this last syntax it is possible to generalize INSERT and UPDATE Ops

---------------------------------------------------------------
GENERALIZED INSERT/UPDATE
---------------------------------------------------------------
- considering the 
    - Comma Separated Fields List
        - [CSFL] = implode(', ', array_slice($array_keys(Matrix[0]), 1));
    - Comma Separated Values List
        - [CSVL] = implode(', ', array_slice($array_values(Matrix[0]), 1));
    - Comma Separated List for UPDATE
        - [CSKLIU] = implode(',',array_map(function ($v, $k) { return $k.'=VALUES('.$k.')'; }, Matrix[0], array_keys(Matrix[0]))),"<br>";

    INSERT INTO [Fundamental Entity]
            ([CSFL])
    VALUES
        foreach ($Matrix as $Row){
            ([CSVL]),
        }
    ON DUPLICATE KEY UPDATE
        [CSLU]
    ;

- SAMPLE in Test db:
    - INSERTED rows have null idT1
    - UPDATED rows have an existing idT1

    INSERT INTO t1 (idT1, nam, descr) VALUES
        (1, '-Linear regression', 'Linear regression'),
        (null , 'nanomalies auto clean', 'alg with compulsory fields'),
        (3, '-Clean', 'Clean'),
        (null , 'nStruct', 'Struct'),
        (null , 'nCompare Train Test', 'Compare Train Test '),
        (6, '-Compare', 'Compare'),
        (null , 'nPolinomial Regression', 'null'),
        (8, '-Logistic Regression', 'Logistic Regression')
    ON DUPLICATE KEY UPDATE
        idT1=VALUES(idT1), nam=VALUES(nam), descr=VALUES(descr)
;        

---------------------------------------------------------------
Data Structure knowledge extraction
---------------------------------------------------------------
- From Functional form: ex for Alg entity:
    - alg(idAlg,idAlgState,idAlgCat,nam,descr,fileRefProc,CatTag)
    - algcat(idAlgCat,idAlgCatPar,nam,descr)
    - ...
- it could be formatted as csv file:
    - conventions:
        - Descriptive Entities Id: '>' postfix or 'Par>' for recursive entities
        - Fundamental Entity Id: 'Id'+[Fundamental Entity]

    -----------         ------------------------
    Entity              Fields
    -----------         ------------------------
    alg                 idAlg,idAlgState>,idAlgCat>,nam,descr,fileRefProc,CatTag
    algcat              idAlgCat,idAlgCatPar>,nam,descr
    ...
- could be usefull to extract metadata and organize them as csv or json or rdbms tables,
    FROM:
    - rdbms metadata of existing db: ex. mysql db
    - rdbms SQL script
    - text docs (to specify)

----------------------------------------------------------
----------------------------------------------------------
DELETE examples: 
----------------------------------------------------------
    Delete			Delete		[Single]
                    Clean		[Filter]
                    Truncate	[All]
----------------------------------------------------------
Single row syntax
    DELETE from Profile p
        WHERE p.IdProfile = '" . $this->IdProfile . "'

Multi row syntax
    DELETE from Profile p
        WHERE p.IdProfile IN ('1,3,6,9,22,456')

Clean Tables
    TRUNCATE TABLE Profile
---------------------------------------------------------------
GENERALIZED DELETE
---------------------------------------------------------------
- considering the 
    - Comma Separated Delete IDS 
        - [CSDI] = implode(', ', array_slice($array_keys(Matrix[0]), 1));

    DELETE from [Fundamental Entity] fe
        WHERE fe.[Fundamental Entity] IN ([CSDI])
    
    and
    
    TRUNCATE TABLE [Fundamental Entity]
---------------------------------------------------------------
CONCLUSIONS
---------------------------------------------------------------
- With this generalization it is possible to have:
    - 1 DAO component class with generalized code;
    - a Knowledge base of:
        - DB>Tables>Fields nanomalies;
        - this Knowledge base could be extracted directly from the DB Script (ex- dadbv01.sql);
    - DAO extensions ONLY if necessary, for special queries;
- Dev Process changes accordingly:
    - REQUISITES: knowledge definition:
        - define App basic attributes: 
            - Name, title, descr, url, logo, ...
            - frameworks for 
                - UI: ex. Adminlte, bootstrap, JS, JQuery; 
                - comms: Ajax, Json, Post;
                - websrv: PHP
                - persistence: 
                    - RDBMS(MariaDb MySql) 
                    - FS(folder tree; file std nams and types)
            - UIExperience:
                - main layout, ex. 
                - std l&f, 
                - std UI components (ex. label, input, select, check, DataTable, ...)
        - define Process Lines/panels: ex. da.navigation.js >> Algs
            - for each panel, 
                - attributes: ex. type, mode, parentPanels, DetailPanels, Refs , ...
                - define Entities functional form:
                    - Fundamental: ex. Alg 
                    - Descriptive: ex. Algcat, AlgState 
        - Save them all in a prj file and/or in RDBMS structure.
    - CODING: automatic code generation:
        - Generate final code for each architecture level, choosing: code generalization level (none: no generalization; entity functional form; ...)
        - Deploy in a testing env, Test and recycle.
        - deploy in prodution env, final test and recycle.

        
       
        
    
